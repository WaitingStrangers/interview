{"version":3,"sources":["../src/browser.ts","../src/browser-utils.ts","../src/exceptions.ts","../src/tts_config.ts","../src/constants.ts","../src/browser-drm.ts","../src/browser-communicate.ts","../src/browser-simple.ts","../src/browser-voices.ts","../src/submaker.ts"],"names":["WIN_EPOCH","S_TO_NS"],"mappings":"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","file":"browser.cjs","sourcesContent":["/**\n * Browser-compatible version of edge-tts Simple API\n * Uses native browser APIs instead of Node.js dependencies\n */\n\n/**\n * Options for controlling the voice prosody (rate, pitch, volume).\n */\nexport interface ProsodyOptions {\n  /**\n   * The speaking rate of the voice.\n   * Examples: \"+10.00%\", \"-20.00%\"\n   */\n  rate?: string;\n  /**\n   * The speaking volume of the voice.\n   * Examples: \"+15.00%\", \"-10.00%\"\n   */\n  volume?: string;\n  /**\n   * The speaking pitch of the voice.\n   * Examples: \"+20Hz\", \"-10Hz\"\n   */\n  pitch?: string;\n}\n\n/**\n * Represents a single word boundary with its timing and text.\n * The API provides timing in 100-nanosecond units.\n */\nexport interface WordBoundary {\n  /**\n   * The offset from the beginning of the audio stream in 100-nanosecond units.\n   */\n  offset: number;\n  /**\n   * The duration of the word in 100-nanosecond units.\n   */\n  duration: number;\n  /**\n   * The text of the spoken word.\n   */\n  text: string;\n}\n\n/**\n * The final result of the synthesis process.\n */\nexport interface SynthesisResult {\n  /**\n   * The generated audio as a Blob, which can be used in an <audio> element.\n   */\n  audio: Blob;\n  /**\n   * An array of word boundaries containing timing and text for creating subtitles.\n   */\n  subtitle: WordBoundary[];\n}\n\n/**\n * Browser-compatible Edge TTS class that uses native browser APIs.\n * \n * @remarks This uses an undocumented Microsoft API. CORS policy may prevent\n * direct usage from web apps. Consider using a proxy server.\n */\nexport class EdgeTTSBrowser {\n  public text: string;\n  public voice: string;\n  public rate: string;\n  public volume: string;\n  public pitch: string;\n\n  private ws: WebSocket | null = null;\n  private readonly WSS_URL = \"wss://speech.platform.bing.com/consumer/speech/synthesize/readaloud/edge/v1\";\n  private readonly TRUSTED_CLIENT_TOKEN = \"6A5AA1D4EAFF4E9FB37E23D68491D6F4\";\n\n  /**\n   * @param text The text to be synthesized.\n   * @param voice The voice to use for synthesis.\n   * @param options Prosody options (rate, volume, pitch).\n   */\n  constructor(\n    text: string,\n    voice = \"Microsoft Server Speech Text to Speech Voice (en-US, EmmaMultilingualNeural)\",\n    options: ProsodyOptions = {}\n  ) {\n    this.text = text;\n    this.voice = voice;\n    this.rate = options.rate || \"+0%\";\n    this.volume = options.volume || \"+0%\";\n    this.pitch = options.pitch || \"+0Hz\";\n  }\n\n  /**\n   * Initiates the synthesis process.\n   * @returns A promise that resolves with the synthesized audio and subtitle data.\n   */\n  public async synthesize(): Promise<SynthesisResult> {\n    await this.connect();\n\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      throw new Error(\"WebSocket is not connected.\");\n    }\n\n    this.ws.send(this.createSpeechConfig());\n    this.ws.send(this.createSSML());\n\n    return new Promise((resolve, reject) => {\n      const audioChunks: Uint8Array[] = [];\n      let wordBoundaries: WordBoundary[] = [];\n\n      if (this.ws) {\n        this.ws.onmessage = (event: MessageEvent) => {\n          if (typeof event.data === \"string\") {\n            // Text message\n            const { headers, body } = this.parseMessage(event.data);\n            if (headers.Path === \"audio.metadata\") {\n              try {\n                const metadata = JSON.parse(body);\n                if (metadata.Metadata && Array.isArray(metadata.Metadata)) {\n                  const boundaries = metadata.Metadata\n                    .filter((item: any) => item.Type === \"WordBoundary\" && item.Data)\n                    .map((item: any) => ({\n                      offset: item.Data.Offset,\n                      duration: item.Data.Duration,\n                      text: item.Data.text.Text,\n                    }));\n                  wordBoundaries = wordBoundaries.concat(boundaries);\n                }\n              } catch (e) {\n                // Ignore JSON parsing errors for metadata\n              }\n            } else if (headers.Path === \"turn.end\") {\n              if (this.ws) this.ws.close();\n            }\n          } else if (event.data instanceof Blob) {\n            // Binary audio message\n            event.data.arrayBuffer().then(arrayBuffer => {\n              const dataView = new DataView(arrayBuffer);\n              const headerLength = dataView.getUint16(0);\n\n              if (arrayBuffer.byteLength > headerLength + 2) {\n                const audioData = new Uint8Array(arrayBuffer, headerLength + 2);\n                audioChunks.push(audioData);\n              }\n            });\n          }\n        };\n\n        this.ws.onclose = () => {\n          const audioBlob = new Blob(audioChunks, { type: \"audio/mpeg\" });\n          resolve({ audio: audioBlob, subtitle: wordBoundaries });\n        };\n\n        this.ws.onerror = (error) => {\n          reject(error);\n        };\n      }\n    });\n  }\n\n  /**\n   * Establishes a connection to the WebSocket server.\n   */\n  private connect(): Promise<void> {\n    const connectionId = this.generateConnectionId();\n    const secMsGec = this.generateSecMsGec();\n    const url = `${this.WSS_URL}?TrustedClientToken=${this.TRUSTED_CLIENT_TOKEN}&ConnectionId=${connectionId}&Sec-MS-GEC=${secMsGec}&Sec-MS-GEC-Version=1-130.0.2849.68`;\n\n    this.ws = new WebSocket(url);\n\n    return new Promise((resolve, reject) => {\n      if (!this.ws) {\n        return reject(new Error(\"WebSocket not initialized\"));\n      }\n      this.ws.onopen = () => {\n        resolve();\n      };\n      this.ws.onerror = (error) => {\n        reject(error);\n      };\n    });\n  }\n\n  /**\n   * Parses a string message from the WebSocket into headers and a body.\n   */\n  private parseMessage(message: string): { headers: Record<string, string>; body: string } {\n    const parts = message.split(\"\\r\\n\\r\\n\");\n    const headerLines = parts[0].split(\"\\r\\n\");\n    const headers: Record<string, string> = {};\n    headerLines.forEach(line => {\n      const [key, value] = line.split(\":\", 2);\n      if (key && value) {\n        headers[key.trim()] = value.trim();\n      }\n    });\n    return { headers, body: parts[1] || '' };\n  }\n\n  /**\n   * Creates the speech configuration message.\n   */\n  private createSpeechConfig(): string {\n    const config = {\n      context: {\n        synthesis: {\n          audio: {\n            metadataoptions: {\n              sentenceBoundaryEnabled: false,\n              wordBoundaryEnabled: true,\n            },\n            outputFormat: \"audio-24khz-48kbitrate-mono-mp3\",\n          },\n        },\n      },\n    };\n    return `X-Timestamp:${this.getTimestamp()}\\r\\nContent-Type:application/json; charset=utf-8\\r\\nPath:speech.config\\r\\n\\r\\n${JSON.stringify(config)}`;\n  }\n\n  /**\n   * Creates the SSML (Speech Synthesis Markup Language) message.\n   */\n  private createSSML(): string {\n    const ssml = `<speak version='1.0' xmlns='http://www.w3.org/2001/10/synthesis' xml:lang='en-US'>\n      <voice name='${this.voice}'>\n        <prosody pitch='${this.pitch}' rate='${this.rate}' volume='${this.volume}'>\n          ${this.escapeXml(this.text)}\n        </prosody>\n      </voice>\n    </speak>`;\n    return `X-RequestId:${this.generateConnectionId()}\\r\\nContent-Type:application/ssml+xml\\r\\nX-Timestamp:${this.getTimestamp()}Z\\r\\nPath:ssml\\r\\n\\r\\n${ssml}`;\n  }\n\n  private generateConnectionId(): string {\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n      const r = (Math.random() * 16) | 0;\n      const v = c === \"x\" ? r : (r & 0x3) | 0x8;\n      return v.toString(16);\n    });\n  }\n\n  private getTimestamp(): string {\n    return new Date().toISOString().replace(/[:-]|\\.\\d{3}/g, \"\");\n  }\n\n  private escapeXml(text: string): string {\n    return text.replace(/[<>&'\"]/g, (char) => {\n      switch (char) {\n        case \"<\": return \"&lt;\";\n        case \">\": return \"&gt;\";\n        case \"&\": return \"&amp;\";\n        case \"'\": return \"&apos;\";\n        case '\"': return \"&quot;\";\n        default: return char;\n      }\n    });\n  }\n\n  /**\n   * Browser-compatible version of DRM security token generation\n   * Uses Web Crypto API instead of Node.js crypto\n   */\n  private async generateSecMsGec(): Promise<string> {\n    const WIN_EPOCH = 11644473600;\n    const S_TO_NS = 1e9;\n\n    let ticks = Date.now() / 1000;\n    ticks += WIN_EPOCH;\n    ticks -= ticks % 300;\n    ticks *= S_TO_NS / 100;\n\n    const strToHash = `${ticks.toFixed(0)}${this.TRUSTED_CLIENT_TOKEN}`;\n\n    // Use Web Crypto API for hashing\n    const encoder = new TextEncoder();\n    const data = encoder.encode(strToHash);\n    const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('').toUpperCase();\n  }\n}\n\n// ==================================================================================\n// Subtitle Generation Utilities (Browser Compatible)\n// ==================================================================================\n\n/**\n * Formats a time value from 100-nanosecond units into a VTT or SRT timestamp string.\n */\nfunction formatTimestamp(timeIn100ns: number, format: 'vtt' | 'srt'): string {\n  const totalSeconds = Math.floor(timeIn100ns / 10000000);\n  const hours = Math.floor(totalSeconds / 3600);\n  const minutes = Math.floor((totalSeconds % 3600) / 60);\n  const seconds = totalSeconds % 60;\n  const milliseconds = Math.floor((timeIn100ns % 10000000) / 10000);\n  const separator = format === 'vtt' ? '.' : ',';\n  return `${padNumber(hours)}:${padNumber(minutes)}:${padNumber(seconds)}${separator}${padNumber(milliseconds, 3)}`;\n}\n\n/**\n * Pads a number with leading zeros to a specified length.\n */\nfunction padNumber(num: number, length = 2): string {\n  return num.toString().padStart(length, '0');\n}\n\n/**\n * Creates a subtitle file content in VTT (WebVTT) format.\n */\nexport function createVTT(wordBoundaries: WordBoundary[]): string {\n  let vttContent = \"WEBVTT\\n\\n\";\n  wordBoundaries.forEach((word, index) => {\n    const startTime = formatTimestamp(word.offset, 'vtt');\n    const endTime = formatTimestamp(word.offset + word.duration, 'vtt');\n    vttContent += `${index + 1}\\n`;\n    vttContent += `${startTime} --> ${endTime}\\n`;\n    vttContent += `${word.text}\\n\\n`;\n  });\n  return vttContent;\n}\n\n/**\n * Creates a subtitle file content in SRT (SubRip) format.\n */\nexport function createSRT(wordBoundaries: WordBoundary[]): string {\n  let srtContent = \"\";\n  wordBoundaries.forEach((word, index) => {\n    const startTime = formatTimestamp(word.offset, 'srt');\n    const endTime = formatTimestamp(word.offset + word.duration, 'srt');\n    srtContent += `${index + 1}\\n`;\n    srtContent += `${startTime} --> ${endTime}\\n`;\n    srtContent += `${word.text}\\n\\n`;\n  });\n  return srtContent;\n} ","/**\n * Browser-specific utility functions that avoid Node.js dependencies.\n * Provides browser-native implementations of UUID generation and XML escaping.\n */\n\n/**\n * Generates a UUID v4 string without hyphens using browser's crypto API.\n * @returns UUID string with hyphens removed\n */\nexport function browserConnectId(): string {\n  // Use crypto.getRandomValues for browser-native UUID generation\n  const array = new Uint8Array(16);\n  crypto.getRandomValues(array);\n\n  // Set version (4) and variant bits according to RFC 4122\n  array[6] = (array[6] & 0x0f) | 0x40;\n  array[8] = (array[8] & 0x3f) | 0x80;\n\n  // Convert to hex string and format as UUID, then remove hyphens\n  const hex = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');\n  const uuid = `${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(12, 16)}-${hex.slice(16, 20)}-${hex.slice(20, 32)}`;\n\n  return uuid.replace(/-/g, '');\n}\n\n/**\n * Browser-native XML escaping function.\n * @param text - Text to escape\n * @returns XML-escaped text\n */\nexport function browserEscape(text: string): string {\n  return text\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&apos;');\n}\n\n/**\n * Unescapes XML entities in text.\n * @param text - Text containing XML entities to unescape\n * @returns Text with XML entities converted back to their original characters\n */\nexport function browserUnescape(text: string): string {\n  return text\n    .replace(/&quot;/g, '\"')\n    .replace(/&apos;/g, \"'\")\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&amp;/g, '&'); // Do &amp; last to avoid double unescaping\n}\n\n/**\n * Removes control characters that are incompatible with TTS processing.\n * @param text - Input text to clean\n * @returns Text with control characters replaced by spaces\n */\nexport function browserRemoveIncompatibleCharacters(text: string): string {\n  // Remove control characters (U+0000 to U+001F except \\t, \\n, \\r)\n  // eslint-disable-next-line no-control-regex\n  return text.replace(/[\\u0000-\\u0008\\u000B\\u000C\\u000E-\\u001F]/g, ' ');\n}\n\n/**\n * Formats the current date as a string in the format expected by the TTS service.\n * @returns Formatted date string\n */\nexport function browserDateToString(): string {\n  return new Date().toUTCString().replace(\"GMT\", \"GMT+0000 (Coordinated Universal Time)\");\n}\n\n/**\n * Creates SSML (Speech Synthesis Markup Language) from text and voice configuration.\n * @param voice - Voice name\n * @param rate - Speech rate (e.g., \"+0%\")\n * @param volume - Speech volume (e.g., \"+0%\") \n * @param pitch - Speech pitch (e.g., \"+0Hz\")\n * @param escapedText - Text content (should be XML-escaped)\n * @returns Complete SSML document string\n */\nexport function browserMkssml(voice: string, rate: string, volume: string, pitch: string, escapedText: string): string {\n  return (\n    \"<speak version='1.0' xmlns='http://www.w3.org/2001/10/synthesis' xml:lang='en-US'>\"\n    + `<voice name='${voice}'>`\n    + `<prosody pitch='${pitch}' rate='${rate}' volume='${volume}'>`\n    + `${escapedText}`\n    + \"</prosody>\"\n    + \"</voice>\"\n    + \"</speak>\"\n  );\n}\n\n/**\n * Creates a complete WebSocket message with headers and SSML data.\n * @param requestId - Unique request identifier\n * @param timestamp - Timestamp string for the request\n * @param ssml - SSML content to include in the message\n * @returns Complete WebSocket message string with headers and data\n */\nexport function browserSsmlHeadersPlusData(requestId: string, timestamp: string, ssml: string): string {\n  return (\n    `X-RequestId:${requestId}\\r\\n`\n    + \"Content-Type:application/ssml+xml\\r\\n\"\n    + `X-Timestamp:${timestamp}Z\\r\\n`  // This is not a mistake, Microsoft Edge bug.\n    + \"Path:ssml\\r\\n\\r\\n\"\n    + `${ssml}`\n  );\n}\n\n/**\n * Calculates the maximum message size for text chunks based on WebSocket limits.\n * @param voice - Voice name\n * @param rate - Speech rate\n * @param volume - Speech volume\n * @param pitch - Speech pitch\n * @returns Maximum byte size for text content in a single message\n */\nexport function browserCalcMaxMesgSize(voice: string, rate: string, volume: string, pitch: string): number {\n  const websocketMaxSize = 2 ** 16;\n  const overheadPerMessage = browserSsmlHeadersPlusData(\n    browserConnectId(),\n    browserDateToString(),\n    browserMkssml(voice, rate, volume, pitch, \"\"),\n  ).length + 50; // margin of error\n  return websocketMaxSize - overheadPerMessage;\n} ","/**\n * Base exception class for all Edge TTS related errors.\n */\nexport class EdgeTTSException extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"EdgeTTSException\";\n  }\n}\n\n/**\n * Exception raised when there's an error adjusting clock skew for API requests.\n * This typically occurs when the client and server clocks are significantly out of sync.\n */\nexport class SkewAdjustmentError extends EdgeTTSException {\n  constructor(message: string) {\n    super(message);\n    this.name = \"SkewAdjustmentError\";\n  }\n}\n\n/**\n * Exception raised when an unknown response is received from the TTS service.\n * This indicates an unexpected message type or format that the client cannot handle.\n */\nexport class UnknownResponse extends EdgeTTSException {\n  constructor(message: string) {\n    super(message);\n    this.name = \"UnknownResponse\";\n  }\n}\n\n/**\n * Exception raised when an unexpected response is received from the TTS service.\n * This indicates a response that doesn't match the expected protocol flow.\n */\nexport class UnexpectedResponse extends EdgeTTSException {\n  constructor(message: string) {\n    super(message);\n    this.name = \"UnexpectedResponse\";\n  }\n}\n\n/**\n * Exception raised when no audio data is received during synthesis.\n * This typically indicates a problem with the synthesis request or service.\n */\nexport class NoAudioReceived extends EdgeTTSException {\n  constructor(message: string) {\n    super(message);\n    this.name = \"NoAudioReceived\";\n  }\n}\n\n/**\n * Exception raised when there's an error with the WebSocket connection.\n * This can occur during connection establishment, data transmission, or connection closure.\n */\nexport class WebSocketError extends EdgeTTSException {\n  constructor(message: string) {\n    super(message);\n    this.name = \"WebSocketError\";\n  }\n}\n\n/**\n * Exception raised when an invalid value is provided to a function or method.\n * This is typically used for input validation errors.\n */\nexport class ValueError extends EdgeTTSException {\n  constructor(message: string) {\n    super(message);\n    this.name = \"ValueError\";\n  }\n} ","import { ValueError } from \"./exceptions\";\n\n/**\n * Interface defining the configuration options for TTS synthesis.\n */\nexport interface ITTSConfig {\n  /** Voice name to use for synthesis */\n  voice: string;\n  /** Speech rate adjustment (e.g., \"+20%\", \"-10%\") */\n  rate: string;\n  /** Volume level adjustment (e.g., \"+50%\", \"-25%\") */\n  volume: string;\n  /** Pitch adjustment in Hz (e.g., \"+5Hz\", \"-10Hz\") */\n  pitch: string;\n}\n\n/**\n * Configuration class for TTS synthesis parameters.\n * Handles voice name normalization and parameter validation.\n * \n * @example\n * ```typescript\n * const config = new TTSConfig({\n *   voice: 'en-US-EmmaMultilingualNeural',\n *   rate: '+20%',\n *   volume: '+10%',\n *   pitch: '+5Hz'\n * });\n * ```\n */\nexport class TTSConfig implements ITTSConfig {\n  public voice: string;\n  public rate: string;\n  public volume: string;\n  public pitch: string;\n\n  /**\n   * Creates a new TTSConfig instance with the specified parameters.\n   * \n   * @param options - Configuration options\n   * @param options.voice - Voice name (supports both short and full formats)\n   * @param options.rate - Speech rate adjustment (default: \"+0%\")\n   * @param options.volume - Volume adjustment (default: \"+0%\") \n   * @param options.pitch - Pitch adjustment (default: \"+0Hz\")\n   * @throws {ValueError} If any parameter has an invalid format\n   */\n  constructor({\n    voice,\n    rate = \"+0%\",\n    volume = \"+0%\",\n    pitch = \"+0Hz\",\n  }: {\n    voice: string,\n    rate?: string,\n    volume?: string,\n    pitch?: string,\n  }) {\n    this.voice = voice;\n    this.rate = rate;\n    this.volume = volume;\n    this.pitch = pitch;\n\n    this.validate();\n  }\n\n  private validate() {\n    // Voice validation and transformation\n    const match = /^([a-z]{2,})-([A-Z]{2,})-(.+Neural)$/.exec(this.voice);\n    if (match) {\n      const [, lang] = match;\n      let [, , region, name] = match;\n      if (name.includes('-')) {\n        const parts = name.split('-');\n        region += `-${parts[0]}`;\n        name = parts[1];\n      }\n      this.voice = `Microsoft Server Speech Text to Speech Voice (${lang}-${region}, ${name})`;\n    }\n\n    TTSConfig.validateStringParam(\n      \"voice\",\n      this.voice,\n      /^Microsoft Server Speech Text to Speech Voice \\(.+,.+\\)$/\n    );\n    TTSConfig.validateStringParam(\"rate\", this.rate, /^[+-]\\d+%$/);\n    TTSConfig.validateStringParam(\"volume\", this.volume, /^[+-]\\d+%$/);\n    TTSConfig.validateStringParam(\"pitch\", this.pitch, /^[+-]\\d+Hz$/);\n  }\n\n  private static validateStringParam(paramName: string, paramValue: string, pattern: RegExp) {\n    if (typeof paramValue !== 'string') {\n      throw new TypeError(`${paramName} must be a string`);\n    }\n    if (!pattern.test(paramValue)) {\n      throw new ValueError(`Invalid ${paramName} '${paramValue}'.`);\n    }\n  }\n} ","/** Base URL for Microsoft Edge TTS service endpoints */\nexport const BASE_URL = \"speech.platform.bing.com/consumer/speech/synthesize/readaloud\";\n\n/** Trusted client token used for authentication with the TTS service */\nexport const TRUSTED_CLIENT_TOKEN = \"6A5AA1D4EAFF4E9FB37E23D68491D6F4\";\n\n/** WebSocket URL for TTS streaming synthesis */\nexport const WSS_URL = `wss://${BASE_URL}/edge/v1?TrustedClientToken=${TRUSTED_CLIENT_TOKEN}`;\n\n/** HTTP URL for fetching available voices list */\nexport const VOICE_LIST_URL = `https://${BASE_URL}/voices/list?trustedclienttoken=${TRUSTED_CLIENT_TOKEN}`;\n\n/** Default voice to use when none is specified */\nexport const DEFAULT_VOICE = \"en-US-EmmaMultilingualNeural\";\n\n/** Version string for Chromium browser emulation */\nexport const CHROMIUM_FULL_VERSION = \"130.0.2849.68\";\n\n/** Major version number extracted from the full Chromium version */\nexport const CHROMIUM_MAJOR_VERSION = CHROMIUM_FULL_VERSION.split(\".\")[0];\n\n/** Security token version for API authentication */\nexport const SEC_MS_GEC_VERSION = `1-${CHROMIUM_FULL_VERSION}`;\n\n/** Base HTTP headers for API requests, mimicking a real browser */\nexport const BASE_HEADERS = {\n  \"User-Agent\": `Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/${CHROMIUM_MAJOR_VERSION}.0.0.0 Safari/537.36 Edg/${CHROMIUM_MAJOR_VERSION}.0.0.0`,\n  \"Accept-Encoding\": \"gzip, deflate, br\",\n  \"Accept-Language\": \"en-US,en;q=0.9\",\n};\n\n/** HTTP headers specific to WebSocket connection requests */\nexport const WSS_HEADERS = {\n  ...BASE_HEADERS,\n  \"Pragma\": \"no-cache\",\n  \"Cache-Control\": \"no-cache\",\n  \"Origin\": \"chrome-extension://jdiccldimpdaibmpdkjnbmckianbfold\",\n};\n\n/** HTTP headers specific to voice list API requests */\nexport const VOICE_HEADERS = {\n  ...BASE_HEADERS,\n  \"Authority\": \"speech.platform.bing.com\",\n  \"Sec-CH-UA\": `\" Not;A Brand\";v=\"99\", \"Microsoft Edge\";v=\"${CHROMIUM_MAJOR_VERSION}\", \"Chromium\";v=\"${CHROMIUM_MAJOR_VERSION}\"`,\n  \"Sec-CH-UA-Mobile\": \"?0\",\n  \"Accept\": \"*/*\",\n  \"Sec-Fetch-Site\": \"none\",\n  \"Sec-Fetch-Mode\": \"cors\",\n  \"Sec-Fetch-Dest\": \"empty\",\n}; ","import { TRUSTED_CLIENT_TOKEN } from './constants';\nimport { SkewAdjustmentError } from \"./exceptions\";\n\nconst WIN_EPOCH = 11644473600;\nconst S_TO_NS = 1e9;\n\n/**\n * Browser-specific DRM class that uses only Web APIs.\n * Uses the Web Crypto API instead of Node.js crypto module.\n */\nexport class BrowserDRM {\n  private static clockSkewSeconds = 0.0;\n\n  static adjClockSkewSeconds(skewSeconds: number) {\n    BrowserDRM.clockSkewSeconds += skewSeconds;\n  }\n\n  static getUnixTimestamp(): number {\n    return Date.now() / 1000 + BrowserDRM.clockSkewSeconds;\n  }\n\n  static parseRfc2616Date(date: string): number | null {\n    try {\n      return new Date(date).getTime() / 1000;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  static handleClientResponseError(response: { status: number; headers: Record<string, string> }) {\n    if (!response.headers) {\n      throw new SkewAdjustmentError(\"No headers in response.\");\n    }\n    const serverDate = response.headers[\"date\"] || response.headers[\"Date\"];\n    if (!serverDate) {\n      throw new SkewAdjustmentError(\"No server date in headers.\");\n    }\n    const serverDateParsed = BrowserDRM.parseRfc2616Date(serverDate);\n    if (serverDateParsed === null) {\n      throw new SkewAdjustmentError(`Failed to parse server date: ${serverDate}`);\n    }\n    const clientDate = BrowserDRM.getUnixTimestamp();\n    BrowserDRM.adjClockSkewSeconds(serverDateParsed - clientDate);\n  }\n\n  static async generateSecMsGec(): Promise<string> {\n    let ticks = BrowserDRM.getUnixTimestamp();\n    ticks += WIN_EPOCH;\n    ticks -= ticks % 300;\n    ticks *= S_TO_NS / 100;\n\n    const strToHash = `${ticks.toFixed(0)}${TRUSTED_CLIENT_TOKEN}`;\n\n    // Use Web Crypto API - guaranteed to be available in browsers\n    const encoder = new TextEncoder();\n    const data = encoder.encode(strToHash);\n    const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('').toUpperCase();\n  }\n} ","import {\n  browserConnectId,\n  browserEscape,\n  browserUnescape,\n  browserSsmlHeadersPlusData,\n  browserDateToString,\n  browserMkssml,\n  browserRemoveIncompatibleCharacters,\n  browserCalcMaxMesgSize\n} from './browser-utils';\nimport {\n  NoAudioReceived,\n  UnexpectedResponse,\n  UnknownResponse,\n  WebSocketError\n} from \"./exceptions\";\nimport { TTSConfig } from './tts_config';\nimport { CommunicateState, TTSChunk } from './types';\nimport { DEFAULT_VOICE, WSS_URL, WSS_HEADERS, SEC_MS_GEC_VERSION } from './constants';\nimport { BrowserDRM } from './browser-drm';\n\n// Browser-specific types (avoiding Node.js Buffer dependency)\nexport type BrowserTTSChunk = {\n  type: \"audio\" | \"WordBoundary\";\n  data?: Uint8Array;\n  duration?: number;\n  offset?: number;\n  text?: string;\n};\n\nexport type BrowserCommunicateState = {\n  partialText: Uint8Array;\n  offsetCompensation: number;\n  lastDurationOffset: number;\n  streamWasCalled: boolean;\n};\n\n// Browser-compatible Buffer utilities\nclass BrowserBuffer {\n  static from(input: string | ArrayBuffer | Uint8Array, encoding?: string): Uint8Array {\n    if (typeof input === 'string') {\n      return new TextEncoder().encode(input);\n    } else if (input instanceof ArrayBuffer) {\n      return new Uint8Array(input);\n    } else if (input instanceof Uint8Array) {\n      return input;\n    }\n    throw new Error('Unsupported input type for BrowserBuffer.from');\n  }\n\n  static concat(arrays: Uint8Array[]): Uint8Array {\n    const totalLength = arrays.reduce((sum, arr) => sum + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const arr of arrays) {\n      result.set(arr, offset);\n      offset += arr.length;\n    }\n    return result;\n  }\n}\n\n// Browser-compatible versions of utility functions\nfunction browserGetHeadersAndDataFromText(message: Uint8Array): [{ [key: string]: string }, Uint8Array] {\n  const messageString = new TextDecoder().decode(message);\n  const headerEndIndex = messageString.indexOf('\\r\\n\\r\\n');\n\n  const headers: { [key: string]: string } = {};\n  if (headerEndIndex !== -1) {\n    const headerString = messageString.substring(0, headerEndIndex);\n    const headerLines = headerString.split('\\r\\n');\n    for (const line of headerLines) {\n      const [key, value] = line.split(':', 2);\n      if (key && value) {\n        headers[key] = value.trim();\n      }\n    }\n  }\n\n  const headerByteLength = new TextEncoder().encode(messageString.substring(0, headerEndIndex + 4)).length;\n  return [headers, message.slice(headerByteLength)];\n}\n\nfunction browserGetHeadersAndDataFromBinary(message: Uint8Array): [{ [key: string]: string }, Uint8Array] {\n  if (message.length < 2) {\n    throw new Error('Message too short to contain header length');\n  }\n\n  const headerLength = (message[0] << 8) | message[1]; // Read big-endian uint16\n  const headers: { [key: string]: string } = {};\n\n  if (headerLength > 0 && headerLength + 2 <= message.length) {\n    const headerBytes = message.slice(2, headerLength + 2);\n    const headerString = new TextDecoder().decode(headerBytes);\n    const headerLines = headerString.split('\\r\\n');\n    for (const line of headerLines) {\n      const [key, value] = line.split(':', 2);\n      if (key && value) {\n        headers[key] = value.trim();\n      }\n    }\n  }\n\n  return [headers, message.slice(headerLength + 2)];\n}\n\nfunction browserSplitTextByByteLength(text: string, byteLength: number): Generator<Uint8Array> {\n  return (function* () {\n    let buffer = new TextEncoder().encode(text);\n\n    if (byteLength <= 0) {\n      throw new Error(\"byteLength must be greater than 0\");\n    }\n\n    while (buffer.length > byteLength) {\n      let splitAt = byteLength;\n\n      // Try to find a good split point (space or newline)\n      const slice = buffer.slice(0, byteLength);\n      const sliceText = new TextDecoder().decode(slice);\n      const lastNewline = sliceText.lastIndexOf('\\n');\n      const lastSpace = sliceText.lastIndexOf(' ');\n\n      if (lastNewline > 0) {\n        splitAt = new TextEncoder().encode(sliceText.substring(0, lastNewline)).length;\n      } else if (lastSpace > 0) {\n        splitAt = new TextEncoder().encode(sliceText.substring(0, lastSpace)).length;\n      }\n\n      const chunk = buffer.slice(0, splitAt);\n      const chunkText = new TextDecoder().decode(chunk).trim();\n      if (chunkText) {\n        yield new TextEncoder().encode(chunkText);\n      }\n\n      buffer = buffer.slice(splitAt);\n    }\n\n    const remainingText = new TextDecoder().decode(buffer).trim();\n    if (remainingText) {\n      yield new TextEncoder().encode(remainingText);\n    }\n  })();\n}\n\n/**\n * Configuration options for the browser Communicate class.\n */\nexport interface BrowserCommunicateOptions {\n  /** Voice to use for synthesis (e.g., \"en-US-EmmaMultilingualNeural\") */\n  voice?: string;\n  /** Speech rate adjustment (e.g., \"+20%\", \"-10%\") */\n  rate?: string;\n  /** Volume level adjustment (e.g., \"+50%\", \"-25%\") */\n  volume?: string;\n  /** Pitch adjustment in Hz (e.g., \"+5Hz\", \"-10Hz\") */\n  pitch?: string;\n  /** WebSocket connection timeout in milliseconds */\n  connectionTimeout?: number;\n}\n\n/**\n * Browser-specific Communicate class that uses only browser-native APIs.\n * Uses native WebSocket and Web Crypto API, avoiding any Node.js dependencies.\n * \n * @example\n * ```typescript\n * const communicate = new BrowserCommunicate('Hello, world!', {\n *   voice: 'en-US-EmmaMultilingualNeural',\n * });\n * \n * for await (const chunk of communicate.stream()) {\n *   if (chunk.type === 'audio' && chunk.data) {\n *     // Handle audio data\n *   }\n * }\n * ```\n */\nexport class BrowserCommunicate {\n  private readonly ttsConfig: TTSConfig;\n  private readonly texts: Generator<Uint8Array>;\n  private readonly connectionTimeout?: number;\n\n  private state: BrowserCommunicateState = {\n    partialText: BrowserBuffer.from(''),\n    offsetCompensation: 0,\n    lastDurationOffset: 0,\n    streamWasCalled: false,\n  };\n\n  /**\n   * Creates a new browser Communicate instance for text-to-speech synthesis.\n   * \n   * @param text - The text to synthesize\n   * @param options - Configuration options for synthesis\n   */\n  constructor(text: string, options: BrowserCommunicateOptions = {}) {\n    this.ttsConfig = new TTSConfig({\n      voice: options.voice || DEFAULT_VOICE,\n      rate: options.rate,\n      volume: options.volume,\n      pitch: options.pitch,\n    });\n\n    if (typeof text !== 'string') {\n      throw new TypeError('text must be a string');\n    }\n\n    this.texts = browserSplitTextByByteLength(\n      browserEscape(browserRemoveIncompatibleCharacters(text)),\n      // browserCalcMaxMesgSize(this.ttsConfig.voice, this.ttsConfig.rate, this.ttsConfig.volume, this.ttsConfig.pitch),\n      4096,\n    );\n\n    this.connectionTimeout = options.connectionTimeout;\n  }\n\n  private parseMetadata(data: Uint8Array): BrowserTTSChunk {\n    const metadata = JSON.parse(new TextDecoder().decode(data));\n    for (const metaObj of metadata['Metadata']) {\n      const metaType = metaObj['Type'];\n      if (metaType === 'WordBoundary') {\n        const currentOffset = metaObj['Data']['Offset'] + this.state.offsetCompensation;\n        const currentDuration = metaObj['Data']['Duration'];\n        return {\n          type: metaType,\n          offset: currentOffset,\n          duration: currentDuration,\n          text: browserUnescape(metaObj['Data']['text']['Text']),\n        };\n      }\n      if (metaType === 'SessionEnd') {\n        continue;\n      }\n      throw new UnknownResponse(`Unknown metadata type: ${metaType}`);\n    }\n    throw new UnexpectedResponse('No WordBoundary metadata found');\n  }\n\n  private async * _stream(): AsyncGenerator<BrowserTTSChunk, void, unknown> {\n    const url = `${WSS_URL}&Sec-MS-GEC=${await BrowserDRM.generateSecMsGec()}&Sec-MS-GEC-Version=${SEC_MS_GEC_VERSION}&ConnectionId=${browserConnectId()}`;\n\n    const websocket = new WebSocket(url);\n    const messageQueue: (BrowserTTSChunk | Error | 'close')[] = [];\n    let resolveMessage: (() => void) | null = null;\n\n    // Set connection timeout if specified\n    let timeoutId: number | undefined;\n    if (this.connectionTimeout) {\n      timeoutId = window.setTimeout(() => {\n        websocket.close();\n        messageQueue.push(new WebSocketError('Connection timeout'));\n        if (resolveMessage) resolveMessage();\n      }, this.connectionTimeout);\n    }\n\n    websocket.onmessage = (event: MessageEvent) => {\n      // Clear timeout on first message\n      if (timeoutId) {\n        window.clearTimeout(timeoutId);\n        timeoutId = undefined;\n      }\n\n      const data = event.data;\n      const isBinary = data instanceof ArrayBuffer || data instanceof Blob;\n\n      if (typeof data === 'string') {\n        // Text message\n        const [headers, parsedData] = browserGetHeadersAndDataFromText(BrowserBuffer.from(data));\n\n        const path = headers['Path'];\n        if (path === 'audio.metadata') {\n          try {\n            const parsedMetadata = this.parseMetadata(parsedData);\n            this.state.lastDurationOffset = parsedMetadata.offset! + parsedMetadata.duration!;\n            messageQueue.push(parsedMetadata);\n          } catch (e) {\n            messageQueue.push(e as Error);\n          }\n        } else if (path === 'turn.end') {\n          this.state.offsetCompensation = this.state.lastDurationOffset;\n          websocket.close();\n        } else if (path !== 'response' && path !== 'turn.start') {\n          messageQueue.push(new UnknownResponse(`Unknown path received: ${path}`));\n        }\n      } else if (data instanceof ArrayBuffer) {\n        // Binary message\n        const bufferData = BrowserBuffer.from(data);\n        if (bufferData.length < 2) {\n          messageQueue.push(new UnexpectedResponse('We received a binary message, but it is missing the header length.'));\n        } else {\n          const [headers, audioData] = browserGetHeadersAndDataFromBinary(bufferData);\n\n          if (headers['Path'] !== 'audio') {\n            messageQueue.push(new UnexpectedResponse('Received binary message, but the path is not audio.'));\n          } else {\n            const contentType = headers['Content-Type'];\n            if (contentType !== 'audio/mpeg') {\n              if (audioData.length > 0) {\n                messageQueue.push(new UnexpectedResponse('Received binary message, but with an unexpected Content-Type.'));\n              }\n            } else if (audioData.length === 0) {\n              messageQueue.push(new UnexpectedResponse('Received binary message, but it is missing the audio data.'));\n            } else {\n              messageQueue.push({ type: 'audio', data: audioData });\n            }\n          }\n        }\n      } else if (data instanceof Blob) {\n        // Handle Blob data (convert to ArrayBuffer first)\n        data.arrayBuffer().then(arrayBuffer => {\n          const bufferData = BrowserBuffer.from(arrayBuffer);\n          if (bufferData.length < 2) {\n            messageQueue.push(new UnexpectedResponse('We received a binary message, but it is missing the header length.'));\n          } else {\n            const [headers, audioData] = browserGetHeadersAndDataFromBinary(bufferData);\n\n            if (headers['Path'] !== 'audio') {\n              messageQueue.push(new UnexpectedResponse('Received binary message, but the path is not audio.'));\n            } else {\n              const contentType = headers['Content-Type'];\n              if (contentType !== 'audio/mpeg') {\n                if (audioData.length > 0) {\n                  messageQueue.push(new UnexpectedResponse('Received binary message, but with an unexpected Content-Type.'));\n                }\n              } else if (audioData.length === 0) {\n                messageQueue.push(new UnexpectedResponse('Received binary message, but it is missing the audio data.'));\n              } else {\n                messageQueue.push({ type: 'audio', data: audioData });\n              }\n            }\n          }\n          if (resolveMessage) resolveMessage();\n        });\n      }\n\n      if (resolveMessage) resolveMessage();\n    };\n\n    websocket.onerror = (error: Event) => {\n      if (timeoutId) {\n        window.clearTimeout(timeoutId);\n        timeoutId = undefined;\n      }\n      messageQueue.push(new WebSocketError('WebSocket error occurred'));\n      if (resolveMessage) resolveMessage();\n    };\n\n    websocket.onclose = () => {\n      if (timeoutId) {\n        window.clearTimeout(timeoutId);\n        timeoutId = undefined;\n      }\n      messageQueue.push('close');\n      if (resolveMessage) resolveMessage();\n    };\n\n    await new Promise<void>((resolve, reject) => {\n      websocket.onopen = () => {\n        if (timeoutId) {\n          window.clearTimeout(timeoutId);\n          timeoutId = undefined;\n        }\n        resolve();\n      };\n\n      // Set up a timeout for connection establishment\n      if (this.connectionTimeout) {\n        setTimeout(() => {\n          if (websocket.readyState === WebSocket.CONNECTING) {\n            websocket.close();\n            reject(new WebSocketError('Connection timeout'));\n          }\n        }, this.connectionTimeout);\n      }\n    });\n\n    websocket.send(\n      `X-Timestamp:${browserDateToString()}\\r\\n`\n      + 'Content-Type:application/json; charset=utf-8\\r\\n'\n      + 'Path:speech.config\\r\\n\\r\\n'\n      + '{\"context\":{\"synthesis\":{\"audio\":{\"metadataoptions\":{'\n      + '\"sentenceBoundaryEnabled\":\"false\",\"wordBoundaryEnabled\":\"true\"},'\n      + '\"outputFormat\":\"audio-24khz-48kbitrate-mono-mp3\"'\n      + '}}}}\\r\\n'\n    );\n\n    websocket.send(\n      browserSsmlHeadersPlusData(\n        browserConnectId(),\n        browserDateToString(),\n        browserMkssml(this.ttsConfig.voice, this.ttsConfig.rate, this.ttsConfig.volume, this.ttsConfig.pitch, new TextDecoder().decode(this.state.partialText)),\n      )\n    );\n\n    let audioWasReceived = false;\n    while (true) {\n      if (messageQueue.length > 0) {\n        const message = messageQueue.shift()!;\n        if (message === 'close') {\n          if (!audioWasReceived) {\n            throw new NoAudioReceived('No audio was received.');\n          }\n          break;\n        } else if (message instanceof Error) {\n          throw message;\n        } else {\n          if (message.type === 'audio') audioWasReceived = true;\n          yield message;\n        }\n      } else {\n        // Use a more responsive wait mechanism\n        await new Promise<void>(resolve => {\n          resolveMessage = resolve;\n          // Add a small timeout to prevent indefinite waiting\n          setTimeout(resolve, 50);\n        });\n      }\n    }\n  }\n\n  /**\n   * Streams text-to-speech synthesis results using native browser WebSocket.\n   * Uses only browser-native APIs, avoiding Node.js dependencies.\n   * \n   * @yields BrowserTTSChunk - Audio data or word boundary information\n   * @throws {Error} If called more than once\n   * @throws {NoAudioReceived} If no audio data is received\n   * @throws {WebSocketError} If WebSocket connection fails\n   */\n  async * stream(): AsyncGenerator<BrowserTTSChunk, void, unknown> {\n    if (this.state.streamWasCalled) {\n      throw new Error('stream can only be called once.');\n    }\n    this.state.streamWasCalled = true;\n\n    for (const partialText of this.texts) {\n      this.state.partialText = partialText;\n      for await (const message of this._stream()) {\n        yield message;\n      }\n    }\n  }\n} ","import { BrowserCommunicate, BrowserTTSChunk } from './browser-communicate';\n\n/**\n * Options for controlling the voice prosody (rate, pitch, volume).\n */\nexport interface ProsodyOptions {\n  /**\n   * The speaking rate of the voice.\n   * Examples: \"+10.00%\", \"-20.00%\"\n   */\n  rate?: string;\n  /**\n   * The speaking volume of the voice.\n   * Examples: \"+15.00%\", \"-10.00%\"\n   */\n  volume?: string;\n  /**\n   * The speaking pitch of the voice.\n   * Examples: \"+20Hz\", \"-10Hz\"\n   */\n  pitch?: string;\n}\n\n/**\n * Represents a single word boundary with its timing and text.\n * The API provides timing in 100-nanosecond units.\n */\nexport interface WordBoundary {\n  /**\n   * The offset from the beginning of the audio stream in 100-nanosecond units.\n   */\n  offset: number;\n  /**\n   * The duration of the word in 100-nanosecond units.\n   */\n  duration: number;\n  /**\n   * The text of the spoken word.\n   */\n  text: string;\n}\n\n/**\n * The final result of the synthesis process.\n */\nexport interface SynthesisResult {\n  /**\n   * The generated audio as a Blob, which can be used in an <audio> element.\n   */\n  audio: Blob;\n  /**\n   * An array of word boundaries containing timing and text for creating subtitles.\n   */\n  subtitle: WordBoundary[];\n}\n\n// Browser-compatible buffer concatenation utility with improved audio handling\nfunction concatUint8Arrays(arrays: Uint8Array[]): Uint8Array {\n  if (arrays.length === 0) return new Uint8Array(0);\n  if (arrays.length === 1) return arrays[0];\n\n  // For audio data, we want to ensure smooth concatenation\n  const totalLength = arrays.reduce((sum, arr) => sum + arr.length, 0);\n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n\n  for (const arr of arrays) {\n    if (arr.length > 0) {\n      result.set(arr, offset);\n      offset += arr.length;\n    }\n  }\n\n  return result;\n}\n\n/**\n * Browser-specific Edge TTS class that uses only browser-native APIs.\n * Avoids any Node.js dependencies that could cause issues in browser environments.\n */\nexport class BrowserEdgeTTS {\n  public text: string;\n  public voice: string;\n  public rate: string;\n  public volume: string;\n  public pitch: string;\n\n  /**\n   * @param text The text to be synthesized.\n   * @param voice The voice to use for synthesis.\n   * @param options Prosody options (rate, volume, pitch).\n   */\n  constructor(\n    text: string,\n    voice = \"Microsoft Server Speech Text to Speech Voice (en-US, EmmaMultilingualNeural)\",\n    options: ProsodyOptions = {}\n  ) {\n    this.text = text;\n    this.voice = voice;\n    this.rate = options.rate || \"+0%\";\n    this.volume = options.volume || \"+0%\";\n    this.pitch = options.pitch || \"+0Hz\";\n  }\n\n  /**\n   * Initiates the synthesis process using browser-native APIs.\n   * @returns A promise that resolves with the synthesized audio and subtitle data.\n   */\n  public async synthesize(): Promise<SynthesisResult> {\n    const communicate = new BrowserCommunicate(this.text, {\n      voice: this.voice,\n      rate: this.rate,\n      volume: this.volume,\n      pitch: this.pitch,\n    });\n\n    const audioChunks: Uint8Array[] = [];\n    const wordBoundaries: WordBoundary[] = [];\n\n    for await (const chunk of communicate.stream()) {\n      if (chunk.type === 'audio' && chunk.data) {\n        audioChunks.push(chunk.data);\n      } else if (chunk.type === 'WordBoundary' && chunk.offset !== undefined && chunk.duration !== undefined && chunk.text !== undefined) {\n        wordBoundaries.push({\n          offset: chunk.offset,\n          duration: chunk.duration,\n          text: chunk.text,\n        });\n      }\n    }\n\n    // Convert Uint8Array chunks to Blob\n    const audioBuffer = concatUint8Arrays(audioChunks);\n    const audioBlob = new Blob([audioBuffer], { type: \"audio/mpeg\" });\n\n    return {\n      audio: audioBlob,\n      subtitle: wordBoundaries,\n    };\n  }\n}\n\n// ==================================================================================\n// Subtitle Generation Utilities (Browser Compatible)\n// ==================================================================================\n\n/**\n * Formats a time value from 100-nanosecond units into a VTT or SRT timestamp string.\n * @param timeIn100ns The time value in 100-nanosecond units.\n * @param format The subtitle format, which determines the decimal separator.\n * @returns A formatted timestamp string (e.g., \"00:01:23.456\").\n */\nfunction formatTimestamp(timeIn100ns: number, format: 'vtt' | 'srt'): string {\n  const totalSeconds = Math.floor(timeIn100ns / 10000000);\n  const hours = Math.floor(totalSeconds / 3600);\n  const minutes = Math.floor((totalSeconds % 3600) / 60);\n  const seconds = totalSeconds % 60;\n  const milliseconds = Math.floor((timeIn100ns % 10000000) / 10000);\n  const separator = format === 'vtt' ? '.' : ',';\n  return `${padNumber(hours)}:${padNumber(minutes)}:${padNumber(seconds)}${separator}${padNumber(milliseconds, 3)}`;\n}\n\n/**\n * Pads a number with leading zeros to a specified length.\n * @param num The number to pad.\n * @param length The desired length of the string.\n * @returns The padded number as a string.\n */\nfunction padNumber(num: number, length = 2): string {\n  return num.toString().padStart(length, '0');\n}\n\n/**\n * Creates a subtitle file content in VTT (WebVTT) format.\n * @param wordBoundaries The array of word boundary data.\n * @returns A string containing the VTT formatted subtitles.\n */\nexport function createVTT(wordBoundaries: WordBoundary[]): string {\n  let vttContent = \"WEBVTT\\n\\n\";\n  wordBoundaries.forEach((word, index) => {\n    const startTime = formatTimestamp(word.offset, 'vtt');\n    const endTime = formatTimestamp(word.offset + word.duration, 'vtt');\n    vttContent += `${index + 1}\\n`;\n    vttContent += `${startTime} --> ${endTime}\\n`;\n    vttContent += `${word.text}\\n\\n`;\n  });\n  return vttContent;\n}\n\n/**\n * Creates a subtitle file content in SRT (SubRip) format.\n * @param wordBoundaries The array of word boundary data.\n * @returns A string containing the SRT formatted subtitles.\n */\nexport function createSRT(wordBoundaries: WordBoundary[]): string {\n  let srtContent = \"\";\n  wordBoundaries.forEach((word, index) => {\n    const startTime = formatTimestamp(word.offset, 'srt');\n    const endTime = formatTimestamp(word.offset + word.duration, 'srt');\n    srtContent += `${index + 1}\\n`;\n    srtContent += `${startTime} --> ${endTime}\\n`;\n    srtContent += `${word.text}\\n\\n`;\n  });\n  return srtContent;\n} ","import { SEC_MS_GEC_VERSION, VOICE_HEADERS, VOICE_LIST_URL } from './constants';\nimport { BrowserDRM } from './browser-drm';\nimport { Voice, VoicesManagerFind, VoicesManagerVoice } from './types';\n\n/**\n * Error class for fetch-related errors (browser-specific)\n */\nexport class BrowserFetchError extends Error {\n  response?: {\n    status: number;\n    headers: Record<string, string>;\n  };\n\n  constructor(message: string, response?: { status: number; headers: Record<string, string> }) {\n    super(message);\n    this.name = 'BrowserFetchError';\n    this.response = response;\n  }\n}\n\nasync function _listVoices(): Promise<Voice[]> {\n  const url = `${VOICE_LIST_URL}&Sec-MS-GEC=${await BrowserDRM.generateSecMsGec()}&Sec-MS-GEC-Version=${SEC_MS_GEC_VERSION}`;\n\n  try {\n    const response = await fetch(url, {\n      headers: VOICE_HEADERS,\n    });\n\n    if (!response.ok) {\n      const headers: Record<string, string> = {};\n      response.headers.forEach((value, key) => {\n        headers[key] = value;\n      });\n\n      throw new BrowserFetchError(`HTTP ${response.status}`, {\n        status: response.status,\n        headers\n      });\n    }\n\n    const data: Voice[] = await response.json();\n\n    for (const voice of data) {\n      voice.VoiceTag.ContentCategories = voice.VoiceTag.ContentCategories.map(c => c.trim() as any);\n      voice.VoiceTag.VoicePersonalities = voice.VoiceTag.VoicePersonalities.map(p => p.trim() as any);\n    }\n\n    return data;\n  } catch (error) {\n    if (error instanceof BrowserFetchError) {\n      throw error;\n    }\n    // Convert other fetch errors to our BrowserFetchError format\n    throw new BrowserFetchError(error instanceof Error ? error.message : 'Unknown fetch error');\n  }\n}\n\n/**\n * Fetches all available voices from the Microsoft Edge TTS service (browser version).\n * Uses native browser fetch API and Web Crypto.\n * \n * @returns Promise resolving to array of available voices\n */\nexport async function listVoices(): Promise<Voice[]> {\n  try {\n    return await _listVoices();\n  } catch (e) {\n    if (e instanceof BrowserFetchError && e.response?.status === 403) {\n      BrowserDRM.handleClientResponseError(e.response);\n      return await _listVoices();\n    }\n    throw e;\n  }\n}\n\n/**\n * Browser-specific utility class for finding and filtering available voices.\n * Uses only browser-native APIs.\n * \n * @example\n * ```typescript\n * const voicesManager = await BrowserVoicesManager.create();\n * const englishVoices = voicesManager.find({ Language: 'en' });\n * ```\n */\nexport class BrowserVoicesManager {\n  private voices: VoicesManagerVoice[] = [];\n  private calledCreate = false;\n\n  /**\n   * Creates a new BrowserVoicesManager instance.\n   * \n   * @param customVoices - Optional custom voice list instead of fetching from API\n   * @returns Promise resolving to BrowserVoicesManager instance\n   */\n  public static async create(customVoices?: Voice[]): Promise<BrowserVoicesManager> {\n    const manager = new BrowserVoicesManager();\n    const voices = customVoices ?? await listVoices();\n    manager.voices = voices.map(voice => ({\n      ...voice,\n      Language: voice.Locale.split('-')[0],\n    }));\n    manager.calledCreate = true;\n    return manager;\n  }\n\n  /**\n   * Finds voices matching the specified criteria.\n   * \n   * @param filter - Filter criteria for voice selection\n   * @returns Array of voices matching the filter\n   * @throws {Error} If called before create()\n   */\n  public find(filter: VoicesManagerFind): VoicesManagerVoice[] {\n    if (!this.calledCreate) {\n      throw new Error('BrowserVoicesManager.find() called before BrowserVoicesManager.create()');\n    }\n\n    return this.voices.filter(voice => {\n      return Object.entries(filter).every(([key, value]) => {\n        return voice[key as keyof VoicesManagerFind] === value;\n      });\n    });\n  }\n} ","import { TTSChunk } from \"./types\";\nimport { ValueError } from \"./exceptions\";\n\ninterface Cue {\n  index: number;\n  start: number; // in seconds\n  end: number; // in seconds\n  content: string;\n}\n\nfunction formatTime(seconds: number): string {\n  const h = Math.floor(seconds / 3600);\n  const m = Math.floor((seconds % 3600) / 60);\n  const s = Math.floor(seconds % 60);\n  const ms = Math.round((seconds - Math.floor(seconds)) * 1000);\n\n  const pad = (num: number, size = 2) => num.toString().padStart(size, '0');\n\n  return `${pad(h)}:${pad(m)}:${pad(s)},${pad(ms, 3)}`;\n}\n\n/**\n * Utility class for generating SRT subtitles from WordBoundary events.\n * \n * @example\n * ```typescript\n * const subMaker = new SubMaker();\n * \n * for await (const chunk of communicate.stream()) {\n *   if (chunk.type === 'WordBoundary') {\n *     subMaker.feed(chunk);\n *   }\n * }\n * \n * const srt = subMaker.getSrt();\n * ```\n */\nexport class SubMaker {\n  private cues: Cue[] = [];\n\n  /**\n   * Adds a WordBoundary chunk to the subtitle maker.\n   * \n   * @param msg - Must be a WordBoundary type chunk with offset, duration, and text\n   * @throws {ValueError} If chunk is not a WordBoundary with required fields\n   */\n  feed(msg: TTSChunk): void {\n    if (msg.type !== 'WordBoundary' || msg.offset === undefined || msg.duration === undefined || msg.text === undefined) {\n      throw new ValueError(\"Invalid message type, expected 'WordBoundary' with offset, duration and text\");\n    }\n\n    // offset and duration are in 100-nanosecond intervals.\n    // srt timestamps are in seconds. 1s = 10^7 * 100ns\n    const start = msg.offset / 1e7;\n    const end = (msg.offset + msg.duration) / 1e7;\n\n    this.cues.push({\n      index: this.cues.length + 1,\n      start: start,\n      end: end,\n      content: msg.text,\n    });\n  }\n\n  /**\n   * Merges consecutive cues to create subtitle entries with multiple words.\n   * This is useful for creating more readable subtitles instead of word-by-word display.\n   * \n   * @param words - Maximum number of words per merged cue\n   * @throws {ValueError} If words parameter is invalid\n   */\n  mergeCues(words: number): void {\n    if (words <= 0) {\n      throw new ValueError(\"Invalid number of words to merge, expected > 0\");\n    }\n    if (this.cues.length === 0) {\n      return;\n    }\n\n    const newCues: Cue[] = [];\n    let currentCue: Cue = this.cues[0];\n\n    for (const cue of this.cues.slice(1)) {\n      if (currentCue.content.split(' ').length < words) {\n        currentCue = {\n          ...currentCue,\n          end: cue.end,\n          content: `${currentCue.content} ${cue.content}`,\n        };\n      } else {\n        newCues.push(currentCue);\n        currentCue = cue;\n      }\n    }\n    newCues.push(currentCue);\n\n    // re-index\n    this.cues = newCues.map((cue, i) => ({ ...cue, index: i + 1 }));\n  }\n\n  /**\n   * Returns the subtitles in SRT format.\n   * \n   * @returns SRT formatted subtitles\n   */\n  getSrt(): string {\n    return this.cues.map(cue => {\n      return `${cue.index}\\r\\n${formatTime(cue.start)} --> ${formatTime(cue.end)}\\r\\n${cue.content}\\r\\n`;\n    }).join('\\r\\n');\n  }\n\n  toString(): string {\n    return this.getSrt();\n  }\n} "]}